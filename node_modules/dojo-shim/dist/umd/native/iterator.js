(function (factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    /**
     * A type guard for checking if something has an Iterable interface
     * @param value The value to type guard against
     */
    function isIterable(value) {
        return value && typeof value[Symbol.iterator] !== 'undefined';
    }
    exports.isIterable = isIterable;
    /**
     * A type guard for checking if something is ArrayLike
     * @param value The value to type guard against
     */
    function isArrayLike(value) {
        return value && typeof value.length !== 'undefined';
    }
    exports.isArrayLike = isArrayLike;
    /**
     * Returns the iterator for an object
     *
     * @param iterable The iterable object to return the iterator for
     */
    function get(iterable) {
        if (isIterable(iterable)) {
            /* have to cast as any, because the assumed index is implicit any */
            return iterable[Symbol.iterator]();
        }
    }
    exports.get = get;
    ;
    /**
     * Shims the functionality of `for ... of` blocks
     *
     * @param iterable The object the provides an interator interface
     * @param callback The callback which will be called for each item of the iterable
     * @param thisArg Optional scope to pass the callback
     */
    function forOf(iterable, callback, thisArg) {
        var broken = false;
        function doBreak() {
            broken = true;
        }
        var iterator = get(iterable);
        if (!iterator) {
            throw new TypeError('Cannot resolve iterator interface.');
        }
        var result = iterator.next();
        /**
         * TypeScript when targetting ES5 will destructure `foo ... of` only for array like objects
         * using a `for` loop.  This obviously causes problems when trying to support iterator
         * functionality and would not make the code transparent between ES5 and ES6, therefore
         * creating our own iterator loop that would work seemlessly, irrespective of the target
         */
        while (!result.done) {
            callback.call(thisArg, result.value, iterable, doBreak);
            if (broken) {
                return;
            }
            result = iterator.next();
        }
    }
    exports.forOf = forOf;
});
//# sourceMappingURL=iterator.js.map